# 13-8. 쓰레드의 실행제어
효율적인 멀티쓰레드 프로그램을 만들기 위해서는 
보다 정교한 스케줄링을 통해 프로세스에게 주어진 자원과 시간을 여러 쓰레드가 낭비없이 잘 사용하도록 프로그래밍 해야 한다. 
쓰레드의 스케줄링을 잘하기 위해서는 쓰레드의 상태와 관련 메서드를 잘 알아야 하는데, 먼저 쓰레드의 스케줄링과 관련된 메서드는 다음과 같다.

![image](https://github.com/GYUNGAEEEE/JAVA/assets/158580466/4cd04953-cc65-40ca-8ad1-21dcf27e05c3)
> resume(), stop(), suspend()는 쓰레드를 교착상태(dead-lock)로 만들기 쉽기 때문에 deprecated되었다.

다음은 쓰레드의 상태이다.

![image](https://github.com/GYUNGAEEEE/JAVA/assets/158580466/90ca1f93-245c-4bc1-9b1a-a9ff792fd553)
> 쓰레드의 상태는 Thread의 getState( )메서드를 호출해서 확인할 수 있다.

다음 그림은 쓰레드의 생성부터 소멸까지의 모든 과정을 그린 것인데, 
앞서 소개한 메서드들에 의해서 쓰레드의 상태가 어떻게 변화되는지를 잘 보여 준다.

![image](https://github.com/GYUNGAEEEE/JAVA/assets/158580466/45b3cb9a-5a0e-42b5-92a6-cb97bc918060)

1. 쓰레드를 생성하고 start()를 호출하면 바로 실행되는 것이 아니라 실행대기열에 저장되어
자신의 차례가 될 때까지 기다려야 한다. 실행대기열은 큐(queue)와 같은 구조로 먼저 실행대기열에 들어온 쓰레드가 먼저 실행된다.

2. 실행대기상태에 있다가 자신의 차례가 되면 실행상태가 된다.

3. 주어진 실행시간이 다되거나 yield()를 만나면 다시 실행대기상태가 되고 다음 차례의 쓰레드가 실행상태가 된다.

4. 실행 중에 suspend(), sleep(), wait(), join(), I/O block에 의해 일시정지상태가 될 수 있다.
I/O block은 입출력작업에서 발생하는 지연상태를 말한다.
사용자의 입력을 기다리는 경우를 예로 들 수 있는데, 이런 경우 일시정지 상태에 있다가 사용자가 입력을 마치면 다시 실행대기 상태가 된다.

5. 지정된 일시정지시간이 다되거나(time-out), notify(), resume(), interrupt()가 호출되면 일시정지상태에서 벗어나
다시 실행대기열에 저장되어 자신의 차례를 기다리게 된다.

6. 실행을 모두 마치거나 stop()이 호출되면 쓰레드는 소멸된다.

> 번호의 순서대로 쓰레드가 수행되는 것은 아니다.
